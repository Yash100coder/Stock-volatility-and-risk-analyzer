     # -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZxZYUa_xUIb4DoDy-sVWwmWjsLOaiBtv
"""

    

from gettext import install
import subprocess
import sys

subprocess.check_call([sys.executable, "-m", "pip", "install", "yfinance"])

"""### Stock Volatility and Risk Analyzer

This tool allows you to analyze the volatility and risk of specified stocks over a given time period. Volatility is measured by the standard deviation of daily returns.
"""

import yfinance as yf
import pandas as pd
import numpy as np

def get_stock_data(ticker, start_date, end_date, market_ticker=None):
    """Fetches historical stock data and optionally market index data from Yahoo Finance."""
    data = {}
    try:
        # Set auto_adjust=False to ensure 'Adj Close' column is present
        stock_data = yf.download(ticker, start=start_date, end=end_date, auto_adjust=False)
        if stock_data.empty:
            print(f"No data found for {ticker} between {start_date} and {end_date}.")
            return None
        data['stock'] = stock_data

        if market_ticker:
            market_data = yf.download(market_ticker, start=start_date, end=end_date, auto_adjust=False)
            if market_data.empty:
                print(f"No market data found for {market_ticker} between {start_date} and {end_date}.")
                # If market data is crucial for later steps, you might want to return None here as well.
                # For now, we'll proceed with just stock data if market data is missing.
            else:
                data['market'] = market_data

        return data
    except Exception as e:
        print(f"Error fetching data for {ticker} or {market_ticker}: {e}")
        return None

def calculate_volatility(df):
    """Calculates daily returns and volatility (standard deviation of returns)."""
    if df is None or df.empty:
        return None
    # Calculate daily returns
    df['Daily_Return'] = df['Adj Close'].pct_change()
    # Calculate volatility (standard deviation of daily returns)
    volatility = df['Daily_Return'].std()
    return volatility

def calculate_beta(stock_returns, market_returns):
    """Calculates beta for a stock against a market index."""
    # Ensure both Series are aligned by date and drop NaNs
    combined_returns = pd.concat([stock_returns, market_returns], axis=1).dropna()
    if combined_returns.empty:
        return None

    # Rename columns for clarity in covariance/variance calculation
    combined_returns.columns = ['stock_returns', 'market_returns']

    covariance = combined_returns['stock_returns'].cov(combined_returns['market_returns'])
    market_variance = combined_returns['market_returns'].var()

    if market_variance == 0:
        return None # Avoid division by zero

    beta = covariance / market_variance
    return beta

# @title Input Stock Symbols and Time Period
stock_symbols_input = "techm,bdl,cdsl,policybazar,polycab,nestleind,mphasis,indigo" # @param {type:"string"}
start_date = "2020-11-01" # @param {type:"string"}
end_date = "2023-12-31" # @param {type:"string"}

def format_indian_stock_symbol(symbol):
    """Appends .NS suffix if it's likely an Indian stock and no suffix is present,
    or maps specific index names to their yfinance tickers, handling various input formats."""
    original_symbol = symbol.strip()
    symbol_upper = original_symbol.upper().replace(' ', '') # Normalize by removing spaces and making uppercase

    # Mapping for common Indian indices with variations
    index_mapping = {
        'NIFTY50': '^NSEI',
        'NIFTY': '^NSEI',
        'BANKNIFTY': '^NSEBANK',
        'BNK': '^NSEBANK',
        'BANK': '^NSEBANK' # Assuming 'BANK' alone refers to BANKNIFTY in this context
    }

    if symbol_upper in index_mapping:
        return index_mapping[symbol_upper]

    # If it's already an index symbol (starts with ^) or has a specific suffix, return as is
    if '.' in original_symbol or original_symbol.startswith('^') or original_symbol.endswith('.NS') or original_symbol.endswith('.BO'):
        return original_symbol

    # For other Indian stocks, assume .NS suffix if not already present
    return f"{symbol_upper}.NS"

stock_symbols = [format_indian_stock_symbol(symbol.strip()) for symbol in stock_symbols_input.split(',')]

volatility_results = {}

for symbol in stock_symbols:
    print(f"\nAnalyzing {symbol}...")
    fetched_data = get_stock_data(symbol, start_date, end_date)
    if fetched_data is not None and 'stock' in fetched_data:
        stock_data = fetched_data['stock']
        daily_returns = stock_data['Adj Close'].pct_change().dropna()
        if not daily_returns.empty:
            avg_volatility = daily_returns.std()
            high_volatility = daily_returns.rolling(window=20).std().max() # 20-day rolling max
            low_volatility = daily_returns.rolling(window=20).std().min()  # 20-day rolling min

            volatility_results[symbol] = {
                'Average Volatility': avg_volatility,
                'Highest Volatility': high_volatility,
                'Lowest Volatility': low_volatility
            }
        else:
            print(f"Insufficient data to calculate returns for {symbol}.")
    else:
        print(f"Could not retrieve data for {symbol}.")

# Display results
if volatility_results:
    results_df = pd.DataFrame.from_dict(volatility_results, orient='index')

    # Convert Series objects in volatility columns to scalar floats
    # Ensure we handle potential cases where the result might not be a Series if there's only one stock.
    for col in ['Average Volatility', 'Highest Volatility', 'Lowest Volatility']:
        results_df[col] = results_df[col].apply(lambda x: x.item() if isinstance(x, pd.Series) else x)

    # Add a 'Risky' column based on a threshold for Average Volatility
    # Reverting to a threshold suitable for standard deviation (e.g., 0.02)
    risk_threshold = 0.02
    results_df['Risky'] = results_df['Average Volatility'] > risk_threshold
    print(f"\n--- Stock Volatility Analysis (Standard Deviation - {start_date} to {end_date}) ---")
    display(results_df)
else:
    print("No volatility results to display.")

"""### Stock Volatility Frequency Table"""

import matplotlib.pyplot as plt
import seaborn as sns

# Prepare data for plotting
plot_df = results_df[['Average Volatility', 'Highest Volatility', 'Lowest Volatility']].copy()
plot_df.index.name = 'Stock'
plot_df_melted = plot_df.reset_index().melt('Stock', var_name='Volatility Metric', value_name='Volatility Value')

# Create the bar chart
plt.figure(figsize=(12, 7))
sns.barplot(x='Stock', y='Volatility Value', hue='Volatility Metric', data=plot_df_melted, palette='viridis')
plt.title('Stock Volatility (Average, Highest, Lowest) for Given Period')
plt.xlabel('Stock Symbol')
plt.ylabel('Volatility (Standard Deviation)')
plt.xticks(rotation=45, ha='right')
plt.legend(title='Volatility Metric')
plt.tight_layout()
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

"""### Interpretation of Volatility Results

*   **Average Volatility**: The typical level of price fluctuation for the stock during the specified period. A higher average indicates a more volatile stock.
*   **Highest Volatility**: The peak volatility experienced by the stock within the period, often indicating times of high uncertainty or significant news.
*   **Lowest Volatility**: The lowest volatility observed, suggesting periods of relative stability or low trading activity.

**Note**: Volatility is a measure of risk. Higher volatility generally implies higher risk but also potentially higher reward. The `rolling(window=20).std()` is used to calculate rolling 20-day standard deviation, which gives a sense of how volatility changes over time, rather than just a single overall figure.
"""